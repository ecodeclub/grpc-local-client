package genclient

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
)

const (
	name    = "protoc-gen-go-grpc-local-client"
	version = "v0.0.1"
)

type Generator struct {
	protoFile *protogen.File
	plugin    *protogen.Plugin
	genFile   *protogen.GeneratedFile
}

func NewGenerator(plugin *protogen.Plugin, f *protogen.File) *Generator {
	fileName := f.GeneratedFilenamePrefix + "_grpc_local_client.pb.go"
	g := plugin.NewGeneratedFile(fileName, f.GoImportPath)
	return &Generator{
		protoFile: f,
		plugin:    plugin,
		genFile:   g,
	}
}

// Generate 方法返回 buffers，便于测试
func (g *Generator) Generate() error {
	g.genFile.P("// Code generated by " + name + ". DO NOT EDIT.")
	g.genFile.P("// versions:")
	g.genFile.P("// - "+name+" ", version)
	g.genFile.P("// - protoc             ", g.getProtocVersion())
	if g.protoFile.Proto.GetOptions().GetDeprecated() {
		g.genFile.P("// ", g.protoFile.Desc.Path(), " is a deprecated file.")
	} else {
		g.genFile.P("// source: ", g.protoFile.Desc.Path())
	}
	g.genFile.P()
	g.write("package ")
	g.genFile.P(g.protoFile.GoPackageName)
	for _, svc := range g.protoFile.Services {
		// type XXXLocalClient
		g.genDefinition(svc)
		// 初始化方法
		g.generateNewFunc(svc)
		// 初始化各种方法
		for _, m := range svc.Methods {
			g.genFile.P()
			g.generateMethod(svc, m)
		}
	}
	return nil
}

func (g *Generator) getProtocVersion() string {
	v := g.plugin.Request.GetCompilerVersion()
	if v == nil {
		return "(unknown)"
	}
	var suffix string
	if s := v.GetSuffix(); s != "" {
		suffix = "-" + s
	}
	return fmt.Sprintf("v%d.%d.%d%s", v.GetMajor(), v.GetMinor(), v.GetPatch(), suffix)
}

func (g *Generator) generateNewFunc(svc *protogen.Service) {
	typeName := g.typeName(svc)
	g.write("func New")
	g.write(typeName)
	g.write("(server " + svc.GoName + "Server) *" + typeName)
	g.p(" {")
	g.p("	return &" + g.typeName(svc) + "{")
	g.p("		server: server,")
	g.p("	}")
	g.p("}")
}

func (g *Generator) genDefinition(svc *protogen.Service) {
	typeName := g.typeName(svc)
	g.p(fmt.Sprintf("var _ %sClient=(*%s)(nil)", svc.GoName, typeName))
	g.write("type ")
	g.write(typeName)
	g.p(" struct {")
	g.write("	server ")
	g.write(svc.GoName)
	g.p("Server")
	g.p("}")
}

func (g *Generator) typeName(svc *protogen.Service) string {
	return svc.GoName + "LocalClient"
}

func (g *Generator) Content() ([]byte, error) {
	return g.genFile.Content()
}

func (g *Generator) write(str string) {
	g.genFile.Write([]byte(str))
}

func (g *Generator) p(str string) {
	g.genFile.P(str)
}

func (g *Generator) generateMethod(svc *protogen.Service, m *protogen.Method) {
	g.write("func (s *")
	g.write(g.typeName(svc))
	g.write(") ")
	g.write(m.GoName)
	ctx := g.genFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "Context",
		GoImportPath: "context",
	})
	g.write("(ctx ")
	g.write(ctx)
	g.write(", req *")
	// g.genFile.Import("context")
	g.write(m.Input.GoIdent.GoName)
	grpc := g.genFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "CallOption",
		GoImportPath: "google.golang.org/grpc",
	})
	g.write(", opts ..." + grpc + ") (*")
	g.write(m.Output.GoIdent.GoName)
	g.p(", error) {")
	g.write("	return s.server.")
	g.write(m.GoName)
	g.p("(ctx, req)")
	g.p("}")
}
